package backend

import (
	"crypto/ed25519"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"log"
	"math/big"
	"os"
	"strings"
	"time"

	"golang.org/x/crypto/ssh"
)

var acceptedKeyTypes = []string{"rsa", "dsa", "ecdsa", "ed25519"}

func (b *Backend) GenerateKeys(keyType, keyName, outputPath string, overwrite bool) (privateKeyPath, publicKeyPath string, err error) {

	var privateKeyBytes []byte
	var publicKeyBytes []byte

	isAccepted := false
	for _, acceptedType := range acceptedKeyTypes {
		if strings.ToLower(keyType) == acceptedType {
			isAccepted = true
			break
		}
	}
	if !isAccepted {
		return "", "", fmt.Errorf("provided key type '%s' is not accepted", keyType)
	}

	privateKeyPath = fmt.Sprintf("%s/%s", outputPath, keyName)
	publicKeyPath = fmt.Sprintf("%s/%s.pub", outputPath, keyName)

	switch keyType {
	case "rsa":
		privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
		if err != nil {
			return "", "", fmt.Errorf("failed to generate RSA key: %w", err)
		}
		privateKeyBytes = x509.MarshalPKCS1PrivateKey(privateKey)
		pub, err := ssh.NewPublicKey(&privateKey.PublicKey)
		if err != nil {
			return "", "", fmt.Errorf("failed to generate RSA public key: %w", err)
		}
		publicKeyBytes = ssh.MarshalAuthorizedKey(pub)

	case "ed25519":
		_, privateKey, err := ed25519.GenerateKey(rand.Reader)
		if err != nil {
			return "", "", fmt.Errorf("failed to generate ED25519 key: %w", err)
		}
		privateKeyBytes, err = x509.MarshalPKCS8PrivateKey(privateKey)
		if err != nil {
			return "", "", fmt.Errorf("failed to marshal ED25519 private key: %w", err)
		}
		pub, err := ssh.NewPublicKey(privateKey.Public().(ed25519.PublicKey))
		if err != nil {
			return "", "", fmt.Errorf("failed to generate ED25519 public key: %w", err)
		}
		publicKeyBytes = ssh.MarshalAuthorizedKey(pub)

	default:
		return "", "", fmt.Errorf("key type '%s' is not supported", keyType)
	}

	err = writeKeyToFile(privateKeyPath, privateKeyBytes)
	if err != nil {
		return "", "", err
	}

	err = writeKeyToFile(publicKeyPath, publicKeyBytes)
	if err != nil {
		return "", "", err
	}

	b.logger.Info("Keys generated successfully")
	return privateKeyPath, publicKeyPath, nil
}

func writeKeyToFile(filePath string, keyBytes []byte) error {
	file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return fmt.Errorf("failed to open file '%s': %w", filePath, err)
	}
	defer file.Close()

	_, err = file.Write(keyBytes)
	if err != nil {
		return fmt.Errorf("failed to write key to file '%s': %w", filePath, err)
	}

	return nil
}

func (b *Backend) GenerateSelfSignedCertificate(certName string) (err error) {
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		log.Printf("Failed to generate private key: %v", err)
		return err
	}

	notBefore := time.Now()
	notAfter := notBefore.Add(52 * 7 * 24 * time.Hour) // 1 year
	serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		log.Printf("Failed to generate serial number: %v", err)
		return err
	}

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization: []string{"Generated by GoPilot"},
		},
		NotBefore:             notBefore,
		NotAfter:              notAfter,
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	certBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		log.Printf("Failed to create certificate: %v", err)
		return err
	}

	privKeyFile, err := os.Create(certName + ".key")
	if err != nil {
		log.Printf("Failed to open %s for writing: %v", certName+".key", err)
		return err
	}
	defer privKeyFile.Close()
	privKeyPEM := pem.EncodeToMemory(&pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(privateKey)})
	privKeyFile.Write(privKeyPEM)

	certFile, err := os.Create(certName + ".crt")
	if err != nil {
		log.Printf("Failed to open %s for writing: %v", certName+".crt", err)
		return err
	}
	defer certFile.Close()
	certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certBytes})
	certFile.Write(certPEM)

	b.logger.Info("Self-signed certificate generated successfully")

	return nil
}
